<!-- the web app takes graph_cond_joint.json as input, processes it,
    then produces distinct ego networks with a dropdown menu for each card -->

<!DOCTYPE html>
<meta charset="utf-8">
<html>

<!-- Bootstrap CSS -->
<link href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css" rel="stylesheet"
    integrity="sha384-1BmE4kWBq78iYhFldvKuhfTAU6auU8tT94WrHftjDbrCEXSU1oBoqyl2QvZ6jIW3" crossorigin="anonymous">

<head>
    <title>Clash Synergy Network</title>
</head>

<body>
    <!-- Nav bar -->
    <nav class="navbar fixed-top navbar-expand-md navbar-dark bg-primary">
        <div class="container-fluid">
            <a class="navbar-brand" href="#">Clash Synergy Network</a>
            <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarNav"
                aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation">
                <span class="navbar-toggler-icon"></span>
            </button>
            <div class="collapse navbar-collapse" id="navbarNav">
                <ul class="navbar-nav">
                    <li class="nav-item">
                        <a class="nav-link active" aria-current="page" href="#" id="full">Full Graph</a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link" href="#" id="ego">Ego Network</a>
                    </li>
                    <li class="nav-item d-flex align-items-center" id="nav-ego-select"></li>
                </ul>
            </div>
        </div>
    </nav>

    <!-- a container for the graph -->
    <div id="container" class="mt-5"></div>

    <!-- Bootstrap 5 JS -->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/js/bootstrap.bundle.min.js"
        integrity="sha384-ka7Sk0Gln4gmtz2MlQnikT1wXgYsOg+OMhuP+IlRH9sENBO0LRn5q+8nbTov4+1p"
        crossorigin="anonymous"></script>

    <!-- d3.js (v7) -->
    <script src="https://d3js.org/d3.v7.min.js"></script>

    <!-- graph function -->
    <script>
        /**
         * a helper function that cleans up card name
         */
        function cleanUpName(originalName) {
            let cleanName = originalName.replaceAll(" ", "_");
            cleanName = cleanName.replaceAll("-", "_");
            cleanName = cleanName.replaceAll("\.", "_");
            return cleanName;
        }

        /**
         * a helper function that return an adjusted cooridinate
         * to restrict nodes within the container's boundaries
         * 
         * coord: x | y
         * bound: width | height (container's)
         * padding: usually the width/height of the node
         */
        function restrictCoordinate(coord, bound, padding) {
            return Math.max(-1 * bound / 2 + padding, Math.min(bound / 2 - padding, coord));
        }

        /**
         * a helper function that creates an id for an edge between two vertices
         */
        function makeEdgeId(v1, v2) {
            return [v1, v2].sort().join("-");
        }

        /**
         * a helper function that changes outline color of current node and its adjacent nodes
         */
        function updateAdjacencyOutline(element, nodeColor, edgeColor, graph) {
            const outlineVal = (nodeColor !== "none") ? `medium solid ${nodeColor}` : "none";

            // modify current element's outline
            d3.select(element)
                .attr("style", `outline: ${outlineVal};`);

            // get a list of adjacent vertex id's and modify their outlines
            const adjList = graph[element.id];
            adjList.forEach(id => {
                d3.select(document.querySelector(`#${id}`))
                    .attr("style", `outline: ${outlineVal};`);
            });

            // make a list of edge class names and modify their color
            const edges = adjList.map(id => makeEdgeId(element.id, id));
            edges.forEach(cls => {
                document.querySelectorAll(`.${cls}`).forEach(element => {
                    d3.select(element)
                        .attr("stroke", edgeColor);
                });
            });
        }

        function getViewportWidth() {
            return Math.max(
                document.body.scrollWidth,
                document.documentElement.scrollWidth,
                document.body.offsetWidth,
                document.documentElement.offsetWidth,
                document.documentElement.clientWidth
            );
        }

        function getViewportHeight() {
            return Math.max(
                document.body.scrollHeight,
                document.documentElement.scrollHeight,
                document.body.offsetHeight,
                document.documentElement.offsetHeight,
                document.documentElement.clientHeight
            );
        }

        /**
         * a function that produces an svg as an interactive graph
         * 
         * ego: null produces full graph, else produces ego network given a card
         */
        async function constructGraph(ego = null) {
            // create list of card-URL mappings for vertex icons
            const cardsResp = await fetch("cards.json");
            const cardsJSON = await cardsResp.json();
            const cardsArray = cardsJSON.items.map(card => {
                const id = cleanUpName(card.name);
                const obj = {};
                obj[id] = { name: card.name, url: card.iconUrls.medium };
                return obj;
            });
            const allCards = cardsArray.reduce(((r, c) => Object.assign(r, c)), {});

            // read in graph json
            const graphResp = await fetch("graph_cond_joint.json?1");
            let graph = await graphResp.json();

            // build ego network if specified
            if (ego) {
                const mainCard = cleanUpName(ego);
                const mainAdj = graph[mainCard];

                const egoNetwork = {};
                egoNetwork[mainCard] = mainAdj;

                mainAdj.forEach(adj => {
                    const adjAdj = graph[adj];
                    egoNetwork[adj] = mainAdj.filter(adj => adjAdj.includes(adj));  // set intersection
                    egoNetwork[adj].push(mainCard);
                });

                graph = egoNetwork;
            }

            // transform graph data into D3-compliant format
            const vertices = Object.keys(graph),
                nodes = vertices.map(d => {
                    const card = allCards[d];
                    return { id: d, name: card.name, url: card.url, group: 1 };
                }),
                links = d3.merge(vertices.map(source => {
                    return graph[source].map(target => {
                        return { source: source, target: target };
                    });
                }));

            // construct forces
            const forceNode = d3.forceManyBody();
            const forceLink = d3.forceLink(links).id(({ index: i }) => vertices[i]);

            // note: full graph and ego network nodes have different charges
            let distance = 200, strength = -100;
            if (ego) { distance = 100; strength = -1000; }

            const simulation = d3.forceSimulation(nodes)
                .force("link", forceLink
                    .distance(distance))
                .force("charge", forceNode
                    .strength(strength))
                .force("center", d3.forceCenter())
                .on("tick", ticked);

            // create DOM elements
            const width = getViewportWidth(), // helper vars - old: 1400 x 700
                height = getViewportHeight() - 40;

            const svg = d3.create("svg")
                .attr("width", width)
                .attr("height", height)
                .attr("viewBox", [-width / 2, -height / 2, width, height])
                .attr("style", "max-width: 100%; height: auto; height: intrinsic;");

            const link = svg.append("g")
                .attr("stroke", "#ccc")
                .attr("stroke-width", 1.5)
                .selectAll("line")
                .data(links)
                .join("line")
                .attr("class", d => makeEdgeId(d.source.id, d.target.id));
            // note: using class instead of id because edges contain duplicates

            const imgWidth = 32, // helper vars
                imgHeight = imgWidth,
                imgX = -1 * imgWidth / 2,
                imgY = imgX;

            const node = svg.append("g")
                .selectAll("image")
                .data(nodes)
                .join("image")
                .attr("id", d => d.id)
                .attr("xlink:href", d => d.url)
                .attr("x", imgX)
                .attr("y", imgY)
                .attr("width", imgWidth)
                .attr("height", imgHeight)
                .call(drag(simulation));

            // add hover effects to nodes
            node
                .on('mouseover', function (d, i) {
                    updateAdjacencyOutline(this, "red", "red", graph);
                })
                .on('mouseout', function (d, i) {
                    updateAdjacencyOutline(this, "none", "#ccc", graph);
                });

            // animation logic
            function ticked() {
                link
                    .attr("x1", d => d.source.x)
                    .attr("y1", d => d.source.y)
                    .attr("x2", d => d.target.x)
                    .attr("y2", d => d.target.y);

                node.attr("transform", d => {
                    // restrict node coordinates to be within container boundaries
                    const newX = restrictCoordinate(d.x, width, imgWidth);
                    const newY = restrictCoordinate(d.y, height, imgHeight);
                    d.x = newX; // important: update source data so that edges (links) can be updated
                    d.y = newY;
                    return "translate(" + newX + "," + newY + ")";
                });
            }

            // node drag logic
            function drag(simulation) {
                function dragstarted(event) {
                    if (!event.active) simulation.alphaTarget(0.3).restart();
                    event.subject.fx = event.subject.x;
                    event.subject.fy = event.subject.y;
                }

                function dragged(event) {
                    event.subject.fx = restrictCoordinate(event.x, width, imgWidth);
                    event.subject.fy = restrictCoordinate(event.y, height, imgHeight);
                }

                function dragended(event) {
                    if (!event.active) simulation.alphaTarget(0);
                    event.subject.fx = null;
                    event.subject.fy = null;
                }

                return d3.drag()
                    .on("start", dragstarted)
                    .on("drag", dragged)
                    .on("end", dragended);
            }

            return svg.node();
        }

        // inserts graph svg into DOM
        function insertGraph(ego = null) {
            constructGraph(ego)
                .then(graph => document.querySelector("#container").appendChild(graph));
        }
    </script>

    <!-- event listeners -->
    <script>
        window.addEventListener("load", () => {
            // insert graph into document
            insertGraph();

            // nav bar full button
            document.querySelector("#full").addEventListener("click", () => {
                // intentional: reload instead of DOM manipulation - reduces lag
                location.reload();
            });

            // nav bar ego button
            document.querySelector("#ego").addEventListener("click", async () => {
                // clear content first
                const container = document.querySelector("#container");
                const navEgoSelect = document.querySelector("#nav-ego-select");
                container.innerHTML = "";
                navEgoSelect.innerHTML = "";

                // make select dropdown menu
                const select = document.createElement("select");
                select.classList.add("form-select", "form-select-sm");

                // all cards available - need their nicely formatted names
                const cardsResp = await fetch("cards.json");
                const cardsJSON = await cardsResp.json();
                let cards = cardsJSON.items.map(item => item.name);

                // cards in the graph
                const graphResp = await fetch("graph_cond_joint.json?1");
                const graph = await graphResp.json();
                const graphVertices = Object.keys(graph);

                // only keep names for cards that exist in the graph
                cards = cards.filter(card => graphVertices.includes(cleanUpName(card)));
                cards.sort();

                // each option is a card
                cards.forEach(card => {
                    const option = document.createElement("option");
                    option.innerText = card;
                    select.appendChild(option);
                });

                // select dropdown is ready
                navEgoSelect.appendChild(select);

                // insert ego network
                insertGraph(select.value);

                // make select dropdown responsive
                select.addEventListener("change", () => {
                    container.innerHTML = "";
                    insertGraph(select.value);
                });

                // update nav bar button highlight
                document.querySelector("#full").classList.remove("active");
                document.querySelector("#ego").classList.add("active");
            });

            // refresh page on window resize
            window.addEventListener("resize", () => {
                setTimeout(() => {
                    location.reload();
                }, 1000);  // pulse 1 second, then refresh
            });
        });
    </script>
</body>

</html>

<!-- 
    <li class="nav-item">
        <a class="nav-link" href="#" id="ego">Ego Network</a>
    </li>
-->