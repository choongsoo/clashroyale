<!DOCTYPE html>

<html lang="en">
    <head>
        <meta charset="utf-8" />
        <meta
            name="viewport"
            content="width=device-width, initial-scale=1, shrink-to-fit=no"
        />
        <title>Clash Synergy Network</title>
        <!-- Bootstrap CSS -->
        <link
            href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css"
            rel="stylesheet"
            integrity="sha384-1BmE4kWBq78iYhFldvKuhfTAU6auU8tT94WrHftjDbrCEXSU1oBoqyl2QvZ6jIW3"
            crossorigin="anonymous"
        />
    </head>

    <body>
        <!-- Nav bar -->
        <nav class="navbar fixed-top navbar-expand-md navbar-dark bg-primary">
            <div class="container-fluid">
                <a class="navbar-brand" href="#">Clash Synergy Network</a>
                <button
                    class="navbar-toggler"
                    type="button"
                    data-bs-toggle="collapse"
                    data-bs-target="#navbarNav"
                    aria-controls="navbarNav"
                    aria-expanded="false"
                    aria-label="Toggle navigation"
                >
                    <span class="navbar-toggler-icon"></span>
                </button>
                <div class="collapse navbar-collapse" id="navbarNav">
                    <ul class="navbar-nav">
                        <li class="nav-item">
                            <a
                                class="nav-link active"
                                aria-current="page"
                                href="#"
                                id="full"
                                >Full Graph</a
                            >
                        </li>
                        <li class="nav-item">
                            <a class="nav-link" href="#" id="ego"
                                >Ego Network</a
                            >
                        </li>
                        <li
                            class="nav-item d-flex align-items-center"
                            id="nav-ego-select"
                        ></li>
                        <li class="nav-item">
                            <a class="nav-link" href="#" id="heatmap"
                                >Heatmap</a
                            >
                        </li>
                        <li class="nav-item">
                            <a class="nav-link" href="#" id="clustergram"
                                >Clustergram</a
                            >
                        </li>
                    </ul>
                </div>
            </div>
        </nav>

        <!-- a container for the graph -->
        <div id="container" class="mt-5"></div>

        <!-- Bootstrap 5 JS -->
        <script
            src="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/js/bootstrap.bundle.min.js"
            integrity="sha384-ka7Sk0Gln4gmtz2MlQnikT1wXgYsOg+OMhuP+IlRH9sENBO0LRn5q+8nbTov4+1p"
            crossorigin="anonymous"
        ></script>

        <!-- d3.js (v7) -->
        <script src="https://d3js.org/d3.v7.min.js"></script>

        <!-- plotly.js -->
        <script src="https://cdn.plot.ly/plotly-2.9.0.min.js"></script>

        <!-- graph function -->
        <script>
            /**
             * a helper function that cleans up card name
             */
            function cleanUpName(originalName) {
                let cleanName = originalName.replaceAll(" ", "_");
                cleanName = cleanName.replaceAll("-", "_");
                cleanName = cleanName.replaceAll("\.", "_");
                return cleanName;
            }

            /**
             * a helper function that return an adjusted cooridinate
             * to restrict nodes within the container's boundaries
             *
             * coord: x | y
             * bound: width | height (container's)
             * padding: usually the width/height of the node
             */
            function restrictCoordinate(coord, bound, padding) {
                return Math.max(
                    (-1 * bound) / 2 + padding,
                    Math.min(bound / 2 - padding, coord)
                );
            }

            /**
             * a helper function that creates an id for an edge between two vertices
             */
            function makeEdgeId(v1, v2) {
                return [v1, v2].sort().join("-");
            }

            /**
             * a helper function that changes outline color of current node and its adjacent nodes
             */
            function updateAdjacencyOutline(
                element,
                nodeColor,
                edgeColor,
                graph
            ) {
                const outlineVal =
                    nodeColor !== "none" ? `medium solid ${nodeColor}` : "none";

                // modify current element's outline
                d3.select(element).attr("style", `outline: ${outlineVal};`);

                // get a list of adjacent vertex id's and modify their outlines
                const adjList = graph[element.id];
                adjList.forEach((id) => {
                    d3.select(document.querySelector(`#${id}`)).attr(
                        "style",
                        `outline: ${outlineVal};`
                    );
                });

                // make a list of edge class names and modify their color
                const edges = adjList.map((id) => makeEdgeId(element.id, id));
                edges.forEach((cls) => {
                    document.querySelectorAll(`.${cls}`).forEach((element) => {
                        d3.select(element).attr("stroke", edgeColor);
                    });
                });
            }

            function getViewportWidth() {
                return Math.max(
                    document.body.scrollWidth,
                    document.documentElement.scrollWidth,
                    document.body.offsetWidth,
                    document.documentElement.offsetWidth,
                    document.documentElement.clientWidth
                );
            }

            function getViewportHeight() {
                return Math.max(
                    document.body.scrollHeight,
                    document.documentElement.scrollHeight,
                    document.body.offsetHeight,
                    document.documentElement.offsetHeight,
                    document.documentElement.clientHeight
                );
            }

            /**
             * a function that produces an svg as an interactive graph
             *
             * ego: null produces full graph, else produces ego network given a card
             */
            async function constructGraph(ego = null) {
                // create list of card-URL mappings for vertex icons
                const cardsResp = await fetch("cards.json");
                const cardsJSON = await cardsResp.json();
                const cardsArray = cardsJSON.items.map((card) => {
                    const id = cleanUpName(card.name);
                    const obj = {};
                    obj[id] = { name: card.name, url: card.iconUrls.medium };
                    return obj;
                });
                const allCards = cardsArray.reduce(
                    (r, c) => Object.assign(r, c),
                    {}
                );

                // read in graph json
                const graphResp = await fetch("graph_lasso_0.001.json?0");
                const weightedGraph = await graphResp.json();
                let graph = weightedGraph.adj;
                const weights = weightedGraph.wgt;
                const maxWeight = Math.max(...Object.values(weights));

                // build ego network if specified
                if (ego) {
                    const mainCard = cleanUpName(ego);
                    const mainAdj = graph[mainCard];

                    const egoNetwork = {};
                    egoNetwork[mainCard] = mainAdj;

                    mainAdj.forEach((adj) => {
                        const adjAdj = graph[adj];
                        egoNetwork[adj] = mainAdj.filter((adj) =>
                            adjAdj.includes(adj)
                        ); // set intersection
                        egoNetwork[adj].push(mainCard);
                    });

                    graph = egoNetwork;
                }

                // transform graph data into D3-compliant format
                const vertices = Object.keys(graph),
                    nodes = vertices.map((d) => {
                        const card = allCards[d];
                        return {
                            id: d,
                            name: card.name,
                            url: card.url,
                            group: 1,
                        };
                    }),
                    links = d3.merge(
                        vertices.map((source) => {
                            return graph[source].map((target) => {
                                return {
                                    source: source,
                                    target: target,
                                    weight:
                                        (weights[source + ":" + target] /
                                            maxWeight) *
                                        30, // quantile, standardize
                                };
                            });
                        })
                    );

                // construct forces
                const forceNode = d3.forceManyBody();
                const forceLink = d3
                    .forceLink(links)
                    .id(({ index: i }) => vertices[i]);

                // note: full graph and ego network nodes have different charges
                let distance = 200,
                    strength = -150;
                if (ego) {
                    distance = 100;
                    strength = -1000;
                }

                const simulation = d3
                    .forceSimulation(nodes)
                    .force("link", forceLink.distance(distance))
                    .force("charge", forceNode.strength(strength))
                    .force("center", d3.forceCenter())
                    .on("tick", ticked);

                // create DOM elements
                const width = getViewportWidth(), // helper vars - old: 1400 x 700
                    height = getViewportHeight() - 40;

                const svg = d3
                    .create("svg")
                    .attr("width", width)
                    .attr("height", height)
                    .attr("viewBox", [-width / 2, -height / 2, width, height])
                    .attr(
                        "style",
                        "max-width: 100%; height: auto; height: intrinsic;"
                    );

                const link = svg
                    .append("g")
                    .attr("stroke", "#ccc")
                    // .attr("stroke-width", 1.5)
                    .selectAll("line")
                    .data(links)
                    .join("line")
                    .attr("stroke-width", (d) => d.weight) // edge width by synergy strength
                    .attr("class", (d) => makeEdgeId(d.source.id, d.target.id));
                // note: using class instead of id because edges contain duplicates

                const imgWidth = 32, // helper vars
                    imgHeight = imgWidth,
                    imgX = (-1 * imgWidth) / 2,
                    imgY = imgX;

                const node = svg
                    .append("g")
                    .selectAll("image")
                    .data(nodes)
                    .join("image")
                    .attr("id", (d) => d.id)
                    .attr("xlink:href", (d) => d.url)
                    .attr("x", imgX)
                    .attr("y", imgY)
                    .attr("width", imgWidth)
                    .attr("height", imgHeight)
                    .call(drag(simulation));

                // add hover effects to nodes
                node.on("mouseover", function (d, i) {
                    updateAdjacencyOutline(this, "red", "red", graph);
                }).on("mouseout", function (d, i) {
                    updateAdjacencyOutline(this, "none", "#ccc", graph);
                });

                // animation logic
                function ticked() {
                    link.attr("x1", (d) => d.source.x)
                        .attr("y1", (d) => d.source.y)
                        .attr("x2", (d) => d.target.x)
                        .attr("y2", (d) => d.target.y);

                    node.attr("transform", (d) => {
                        // restrict node coordinates to be within container boundaries
                        const newX = restrictCoordinate(d.x, width, imgWidth);
                        const newY = restrictCoordinate(d.y, height, imgHeight);
                        d.x = newX; // important: update source data so that edges (links) can be updated
                        d.y = newY;
                        return "translate(" + newX + "," + newY + ")";
                    });
                }

                // node drag logic
                function drag(simulation) {
                    function dragstarted(event) {
                        if (!event.active)
                            simulation.alphaTarget(0.3).restart();
                        event.subject.fx = event.subject.x;
                        event.subject.fy = event.subject.y;
                    }

                    function dragged(event) {
                        event.subject.fx = restrictCoordinate(
                            event.x,
                            width,
                            imgWidth
                        );
                        event.subject.fy = restrictCoordinate(
                            event.y,
                            height,
                            imgHeight
                        );
                    }

                    function dragended(event) {
                        if (!event.active) simulation.alphaTarget(0);
                        event.subject.fx = null;
                        event.subject.fy = null;
                    }

                    return d3
                        .drag()
                        .on("start", dragstarted)
                        .on("drag", dragged)
                        .on("end", dragended);
                }

                return svg.node();
            }

            // inserts graph svg into DOM
            function insertGraph(ego = null) {
                constructGraph(ego).then((graph) =>
                    document.querySelector("#container").appendChild(graph)
                );
            }
        </script>

        <!-- heatmap function -->
        <script>
            // constructs the element
            async function constructHeatmap() {
                // set the dimensions and margins of the graph
                const margin = { top: 100, right: 100, bottom: 100, left: 100 },
                    width = 1100 - margin.left - margin.right,
                    height = 1100 - margin.top - margin.bottom;

                // to return
                const heatmapContainer = d3.create("div");

                // create svg object
                const svg = heatmapContainer
                    .append("svg")
                    .attr("width", width + margin.left + margin.right)
                    .attr("height", height + margin.top + margin.bottom)
                    .append("g")
                    .attr(
                        "transform",
                        `translate(${margin.left}, ${margin.top})`
                    );

                // read the data
                const graphResp = await fetch("graph_lasso_0.001.json?0");
                const weightedGraph = await graphResp.json();
                const weights = weightedGraph.wgt;

                // transform into correct data format
                const uniqueIntCards = Object.keys(weights)
                    .map((interaction) =>
                        interaction.match(".*:").toString().slice(0, -1)
                    ) // keep first card
                    .filter((v, i, a) => a.indexOf(v) === i) // unique
                    .sort();

                const data = [];

                const vertexCardMap = await makeVertexCardMap();

                for (let i = 0; i < uniqueIntCards.length; i++) {
                    const card1 = uniqueIntCards[i];
                    for (let j = 0; j < uniqueIntCards.length; j++) {
                        const card2 = uniqueIntCards[j];
                        const pair = {
                            card1: vertexCardMap[card1],
                            card2: vertexCardMap[card2],
                            weight: weights[card1 + ":" + card2] || 0, // if no weight, use 0
                        };
                        data.push(pair);
                    }
                }

                // labels of row and columns
                const xCards = Array.from(new Set(data.map((d) => d.card1)));
                const yCards = Array.from(new Set(data.map((d) => d.card2)));

                // build X scales and axis:
                const x = d3
                    .scaleBand()
                    .range([0, width])
                    .domain(xCards)
                    .padding(0.05);
                svg.append("g")
                    .style("font-size", 8)
                    .attr("transform", `translate(0, ${height})`)
                    .call(d3.axisBottom(x).tickSize(0))
                    .selectAll("text")
                    .attr("y", 0)
                    .attr("x", 4)
                    .attr("dy", ".35em")
                    .attr("transform", "rotate(90)")
                    .style("text-anchor", "start")
                    .select(".domain")
                    .remove();

                // build Y scales and axis:
                const y = d3
                    .scaleBand()
                    .range([height, 0])
                    .domain(yCards)
                    .padding(0.05);
                svg.append("g")
                    .style("font-size", 8)
                    .call(d3.axisLeft(y).tickSize(0))
                    .select(".domain")
                    .remove();

                // build color scale
                const weightValues = Object.values(weights);
                const maxWeight = Math.max(...weightValues);
                const myColor = d3
                    .scaleSequential()
                    .interpolator(d3.interpolateGreys)
                    .domain([0, maxWeight]);

                // create a tooltip
                const tooltip = heatmapContainer
                    .append("div")
                    .style("position", "absolute")
                    .style("opacity", 0)
                    .attr("class", "tooltip")
                    .style("font-size", "14px")
                    .style("background-color", "white")
                    .style("border", "solid")
                    .style("border-width", "2px")
                    .style("border-radius", "4px")
                    .style("padding", "4px");

                // three function that change the tooltip when user hover / move / leave a cell
                const mouseover = function (event, d) {
                    tooltip.style("opacity", 1);
                    // d3.select(this)
                    // .style("stroke", "black")
                    // .style("opacity", 1)
                };
                const mousemove = function (event, d) {
                    tooltip
                        .html(
                            d.card1 +
                                "<br>" +
                                d.card2 +
                                "<br>" +
                                "Strength: " +
                                d.weight
                        )
                        .style("left", event.pageX + 20 + "px")
                        .style("top", event.pageY - 25 + "px");
                };
                const mouseleave = function (event, d) {
                    tooltip.style("opacity", 0);
                    // d3.select(this)
                    // .style("stroke", "none")
                    // .style("opacity", 0.8)
                };

                // add the squares
                svg.selectAll()
                    .data(data, function (d) {
                        return d.card1 + ":" + d.card2;
                    })
                    .join("rect")
                    .attr("x", function (d) {
                        return x(d.card1);
                    })
                    .attr("y", function (d) {
                        return y(d.card2);
                    })
                    // .attr("rx", 1)
                    // .attr("ry", 1)
                    .attr("width", x.bandwidth())
                    .attr("height", y.bandwidth())
                    .style("fill", function (d) {
                        return myColor(d.weight);
                    })
                    // .style("stroke-width", 4)
                    // .style("stroke", "none")
                    // .style("opacity", 0.8)
                    .on("mouseover", mouseover)
                    .on("mousemove", mousemove)
                    .on("mouseleave", mouseleave);

                // add title to graph
                svg.append("text")
                    .attr("x", 0)
                    .attr("y", -50)
                    .attr("text-anchor", "left")
                    .style("font-size", "22px")
                    .text("Card Synergy Heatmap");

                // add subtitle to graph
                svg.append("text")
                    .attr("x", 0)
                    .attr("y", -20)
                    .attr("text-anchor", "left")
                    .style("font-size", "14px")
                    .style("fill", "grey")
                    .style("max-width", 400)
                    .text(
                        "Synergy strengths are simply the coefficients of interaction terms in our lasso regression model."
                    );

                return heatmapContainer.node();
            }

            // insert element into DOM
            function insertHeatmap() {
                constructHeatmap().then((heatmap) =>
                    document.querySelector("#container").appendChild(heatmap)
                );
            }
        </script>

        <!-- clustergram function -->
        <script>
            async function insertClustergram() {
                // read in div text file
                const clustDivResp = await fetch("clustergram_div.txt?1");
                const clustDivText = await clustDivResp.text();

                // extract plotly div and script content
                const clustDiv = document.createElement("div");
                clustDiv.innerHTML = clustDivText;
                const plotlyDiv = clustDiv.children[0].children[0];
                const plotlyScript = clustDiv.children[0].children[1];

                // add plotly object to DOM
                // note: need to explicitly specify script tag, or it will not work
                const container = document.querySelector("#container");
                container.appendChild(plotlyDiv);
                const containerScript = document.createElement("script");
                containerScript.innerText = plotlyScript.innerText;
                container.appendChild(containerScript);
            }
        </script>

        <!-- event listeners -->
        <script>
            // helper functions
            async function makeVertexCardMap() {
                // all cards available - need their nicely formatted names
                const cardsResp = await fetch("cards.json");
                const cardsJSON = await cardsResp.json();
                let cards = cardsJSON.items.map((item) => item.name);

                // make a hash table that maps vertex names (underscored) to card names (nicely formatted)
                // this will be useful later on
                const vertexCardMap = {};
                cards.forEach((card) => {
                    vertexCardMap[cleanUpName(card)] = card;
                });

                return vertexCardMap;
            }

            async function insertFloatingMenu(
                graph,
                graphVertices,
                mainValue,
                selectedValue,
                container
            ) {
                const floating = document.createElement("div");
                floating.style.zIndex = 100; // this needs to be the highest amongst all elements to float
                floating.style.position = "fixed";
                floating.classList.add(
                    "bg-primary",
                    "text-light",
                    "p-2",
                    "mt-3",
                    "ms-2",
                    "rounded"
                );

                // a user can select from a list of cards that are similar to the main ego card
                const selectSimilar = document.createElement("select");
                selectSimilar.id = "select-similar";
                selectSimilar.classList.add("form-select", "form-select-sm");

                // get set of adjacent cards of curr ego card
                const mainEgo = cleanUpName(mainValue);
                const mainAdjCards = graph[mainEgo];
                const mainAdjVertices = mainAdjCards.map((card) =>
                    cleanUpName(card)
                );

                // iterate through graph (adjacency list) to identify all similar ego cards
                // threshold: having at least 1/2 of the same adjacent cards
                const similarEgos = graphVertices.filter((vertex) => {
                    const currAdjVertices = graph[vertex];
                    // set intersection
                    const mainIntersectCurr = mainAdjVertices.filter((v) =>
                        currAdjVertices.includes(v)
                    );
                    // if similarity size exceeds threshould, filter keeps it
                    return (
                        mainIntersectCurr.length / mainAdjVertices.length >= 0.5
                    );
                });

                similarEgos.sort();

                const vertexCardMap = await makeVertexCardMap();

                // those similar egos will be the options for select-similar
                similarEgos
                    .map((vertex) => vertexCardMap[vertex])
                    .forEach((card) => {
                        const option = document.createElement("option");
                        option.innerText = card;
                        selectSimilar.appendChild(option);
                    });

                selectSimilar.value = selectedValue;

                // label for select-similar
                const selectSimilarLabel = document.createElement("label");
                selectSimilarLabel.htmlFor = "select-similar";
                selectSimilarLabel.innerText = "Similar Ego Card:";
                selectSimilarLabel.style.fontSize = "0.85rem";
                selectSimilarLabel.classList.add("pb-2");

                // insert floating menu to DOM
                floating.appendChild(selectSimilarLabel);
                floating.appendChild(selectSimilar);

                container.appendChild(floating);

                // make select-similar responsive
                selectSimilar.addEventListener("change", async () => {
                    const currSelectSimilarValue = selectSimilar.value;
                    container.innerHTML = "";
                    await insertFloatingMenu(
                        graph,
                        graphVertices,
                        mainValue,
                        currSelectSimilarValue,
                        container
                    );
                    insertGraph(currSelectSimilarValue);
                });
            }

            function clearContainer() {
                const container = document.querySelector("#container");
                const navEgoSelect = document.querySelector("#nav-ego-select");
                container.innerHTML = "";
                navEgoSelect.innerHTML = "";
            }

            // upon window load
            window.addEventListener("load", () => {
                // insert graph into document
                insertGraph();

                // nav bar full button
                document
                    .querySelector("#full")
                    .addEventListener("click", () => {
                        // intentional: reload instead of DOM manipulation - reduces lag
                        location.reload();
                    });

                // nav bar ego button
                document
                    .querySelector("#ego")
                    .addEventListener("click", async () => {
                        // clear content first
                        clearContainer();

                        // make select dropdown menu
                        const select = document.createElement("select");
                        select.classList.add("form-select", "form-select-sm");

                        // all cards available - need their nicely formatted names
                        const cardsResp = await fetch("cards.json");
                        const cardsJSON = await cardsResp.json();
                        let cards = cardsJSON.items.map((item) => item.name);

                        // cards in the graph
                        const graphResp = await fetch(
                            "graph_lasso_0.001.json?0"
                        );
                        const weightedGraph = await graphResp.json();
                        const graph = weightedGraph.adj;
                        const graphVertices = Object.keys(graph);

                        // only keep names for cards that exist in the graph
                        cards = cards.filter((card) =>
                            graphVertices.includes(cleanUpName(card))
                        );
                        cards.sort();

                        // each option is a card
                        cards.forEach((card) => {
                            const option = document.createElement("option");
                            option.innerText = card;
                            select.appendChild(option);
                        });

                        // select dropdown is ready
                        document
                            .querySelector("#nav-ego-select")
                            .appendChild(select);

                        // insert floating menu
                        await insertFloatingMenu(
                            graph,
                            graphVertices,
                            select.value,
                            select.value,
                            container
                        );

                        // insert ego network
                        insertGraph(select.value);

                        // make select dropdown responsive
                        select.addEventListener("change", async () => {
                            container.innerHTML = "";
                            await insertFloatingMenu(
                                graph,
                                graphVertices,
                                select.value,
                                select.value,
                                container
                            );
                            insertGraph(select.value);
                        });

                        // update nav bar button highlight
                        document
                            .querySelector("#full")
                            .classList.remove("active");
                        document
                            .querySelector("#heatmap")
                            .classList.remove("active");
                        document
                            .querySelector("#clustergram")
                            .classList.remove("active");
                        document.querySelector("#ego").classList.add("active");
                    });

                // nav bar heatmap button
                document
                    .querySelector("#heatmap")
                    .addEventListener("click", () => {
                        clearContainer();
                        insertHeatmap();
                        document
                            .querySelector("#full")
                            .classList.remove("active");
                        document
                            .querySelector("#ego")
                            .classList.remove("active");
                        document
                            .querySelector("#clustergram")
                            .classList.remove("active");
                        document
                            .querySelector("#heatmap")
                            .classList.add("active");
                    });

                // nav bar clustergram button
                document
                    .querySelector("#clustergram")
                    .addEventListener("click", () => {
                        clearContainer();
                        insertClustergram();
                        document
                            .querySelector("#full")
                            .classList.remove("active");
                        document
                            .querySelector("#ego")
                            .classList.remove("active");
                        document
                            .querySelector("#heatmap")
                            .classList.remove("active");
                        document
                            .querySelector("#clustergram")
                            .classList.add("active");
                    });

                // // refresh page on window resize
                // window.addEventListener("resize", () => {
                //     setTimeout(() => {
                //         location.reload();
                //     }, 1000);  // pause 1 second, then refresh
                // });
            });
        </script>
    </body>
</html>
